# Chain Manager

{{<js>}}

In order to ensure they are always on the correct latest state of the chain a filecoin full node must accept and process blocks continuously. Blocks are propagated was described in the [Data Propagation](data-propagation.md) document.

Validation is split into two stages, syntactic and semantic. The syntactic stage may be validated without reference to additional data (see [block](data-structures.md#block)). The semantic stage requires access to the chain which the block extends.

A node must decode and perform syntactic validation for every block received before passing it on (e.g. in a lipbp2p pubsub validator). A node must perform semantic validation before accepting the block as an extension to its chain.

### Syntactical Validation

A syntactically valid block:

- must include a well-formed miner address
- must include at least one well-formed ticket, and if more they form a valid ticket chain
- must include an election proof which is a valid signature by the miner address of the final ticket
- must include at least one parent CID
- must include a positive parent weight
- must include a positive height
- must include well-formed state root, messages, and receipts CIDs
- must include a timestamp not in the future


### Semantical Validation

A semantically valid block:

- must be from a valid miner, i.e. has not been slashed
- must only have valid parents in the tipset, meaning
  - that each parent itself must be a valid block
  - all parents must be at same height
- must have a valid ticket:
  - the ticket must be the winning ticket
  - the ticket must be generated from the smallest ticket in the parent tipset
  - all tickets in the ticket array must have been generated by the same miner
  - if it includes intermediary losing tickets in the ticket array, the node must confirm that each ticket correctly generates the next in the array
- must have a valid timestamp, meaning
  - must be later than the earliest parent block time plus appreopriate delay, which is BLOCK_DELAY (30s by default) * len(blk.Tickets).
  see [BLock Validation](mining.md#block-validation)
- must only have valid state transitions:
  - all messages in the block must be valid
  - the execution of each message, in the order they are in the block, must produce a receipt matching the corresponding one in the receipt set of the block, see [the state machine spec](state-machine.md).
- the resulting state root after all messages are applied, must match the one in the block


{{% notice info %}}
Once the block passes validation, it must be added to the local datastore, regardless whether it is understood as the best tip at this point. Future blocks from other miners may be mined on top of it and in that case we will want to have it around to avoid refetching.
{{% /notice %}}

{{% notice info %}}
To make certain validation checks simpler, blocks should be indexed by height and by parent set. That way sets of blocks with a given height and common parents may be quickly queried. It may also be useful to compute and cache the resultant aggregate state of blocks in these sets, this saves extra state computation when checking which state root to start a block at when it has multiple parents.
{{% /notice %}}

### Basic check

{{% notice todo %}}
clarify which of these checks are needed in order to be allowed to validate and propagate a block. This is probably a sub-set of the above mentioned - and thus this paragraph might be moved there - that should be reasonably quick to check and hard to spoof or get around.
{{% /notice %}}






A BlockHeader is verifiable on its own, with the last StateTree but without the rest of the Block,
in the following ways:

- MinerAddress can be validated against current StateTree
- ConsensusTickets can be validated
- ConsensusElectionProof can be validated
- Parents can be checked
- BlockSignature can be verified
- ParentWeight can be calculated and verified
- BlockHeight can be checked against the height of the parents
- Timestamp can be checked to be greater than the parents' timestamp, by around one block time,
  and smaller than the current time.

The following requires having and processing (executing) the messages

- Messages can be checked by verifying the messages hash correctly to the value.
- MessageAggregateSig can be checked by verifying the messages sign correctly
- MessageReceipts can only be checked by executing the messages
- StateRoot is the result of the execution of the messages, and can only be verified by executing them



### Receiving Blocks

When receiving blocks from the network (via [block propagation](data-propagation.md)), a miner must do the following:

1. Check their validity (see [below](#block-validation)).
2. Assemble a TipSet with all valid blocks with common parents and the same number of tickets in their `Tickets` array.

A miner may sometimes receive blocks belonging to different TipSets (i.e. whose parents are not the same). In that case, they must choose which TipSet to mine on.

Chain selection is a crucial component of how the Filecoin blockchain works. Every chain has an associated weight accounting for the number of blocks mined on it and so the power (storage) they track. It is always preferable to mine atop a heavier TipSet rather than a lighter one. While a miner may be foregoing block rewards earned in the past, this lighter chain is likely to be abandoned by other miners forfeiting any block reward earned as miners converge on a final chain. For more on this, see [chain selection](expected-consensus.md#chain-selection) in the Expected Consensus spec.

### Block Validation

The block structure and serialization is detailed in [the datastructures spec - block](data-structures.md#block). Check there for details on fields and types.

In order to validate a block coming in from the network at height `N` was well mined a miner must do the following:

```go
func VerifyBlock(blk Block) {

    // 1. Verify Signature
    pubk := GetPublicKey(blk.Miner)
    if !ValidateSignature(blk.BlockSig, pubk, blk) {
        Fatal("invalid block signature")
    }

    // 2. Verify Timestamp
    // first check that it is not in the future
    // allowing for some small grace period to deal with small asynchrony
    // a potential default for ALLOWABLE_CLOCK_DRIFT could be 2/3*blockTime
    if blk.GetTime() > networkTime() + ALLOWABLE_CLOCK_DRIFT {
        Fatal("block was generated too far in the future")
    }
    // next check that it is appropriately delayed from its parents including
    // null blocks.
    if blk.GetTime() <= blk.minParentTime()+(BLOCK_DELAY*len(blk.Tickets)) {
        Fatal("block was generated too soon")
    }

    // 3. Verify ParentWeight
    if blk.ParentWeight != ComputeWeight(blk.Parents) {
        Fatal("invalid parent weight")
    }

    // 4. Verify Tickets
    if !VerifyTickets(blk) {
        Fatal("tickets were invalid")
    }

    // 5. Verify ElectionProof
    // Note that this step must explicitly check that the
    // miner has not been slashed or is not late to submitting a PoSt
    // i.e. that this is still a valid miner
    if !VerifyElectionProof(blk) {
        Fatal("election was invalid")
    }

    // 6. Verify Message Signatures
    state := GetParentState(blk.Parents)
    blsMessages := LoadMessages(blk.Messages.blsMsgs)

    var blsPubKeys []PublicKey
    for _, msg := range blsMessages {
          blsPubKeys.append(state.LookupPublicKey(msg.From))
    }

    if !ValidateBLSSignature(blk.BLSAggregate, blsMessages, blsPubKeys) {
      Fatal("aggregated bls signature failed to validate")
    }

    secpkMessages := LoadMessages(bls.Messages.secpkMessages)
    for i, msg := range secpkMessages {
      if !ValidateSignature(msg) {
        Fatal("secpk message %d had invalid signature", i)
      }
    }

    // 7. Validate State Transitions
    receipts := LoadReceipts(blk.MessageReceipts)
    for i, msg := range blsMessages {
        receipt := ApplyMessage(state, msg)
        if receipt != receipts[i] {
            Fatal("message receipt mismatch")
        }
    }
    for i, msg := range secpkMessages {
      receipt := ApplyMessage(state, msg.Message)
      if receipt != receipts[i + len(blsMessages)] {
        Fatal("message receipt mismatch")
      }
    }

    if state.Cid() != blk.StateRoot {
        Fatal("state roots mismatch")
    }
}

func (state StateTree) LookupPublicKey(a Address) PubKey {
    act := state.GetActor(a)
    if !act.Code == AccountActor {
        Fatal("only account actors have public keys")
    }

    ast := LoadAccountActorState(act)
    if act.Address.Type == BLS {
        return ExtractBLSPubKey(act.Address)
    }
    Fatal("can only look up public keys for BLS controlled accounts")
}

// Get the canonical randomness from a block.
func GetRandFromBlock(blk) []byte {
	ticket := minTicket(blk)
	return blake2b(ticket)
}
```

If all of this lines up, the block is valid. The miner repeats this for all blocks in a TipSet, and for all TipSets formed from incoming blocks.

Once they've ensured all blocks in the heaviest TipSet received were properly mined, they can mine on top of it. If they weren't, the miner may need to ensure the next heaviest `Tipset` was properly mined. This might mean the same `Tipset` with invalid blocks removed, or an altogether different one.

If no valid blocks are received, a miner may run leader election again (see [ticket generation](expected-consensus.md#ticket-generation)).

### Ticket Validation

For ticket generation, see [ticket generation](expected-consensus.md#ticket-generation).

A ticket can be verified to have been generated in the appropriate number of rounds by looking at the `Tickets` array, and ensuring that each subsequent ticket (leading to the final ticket in that array) was generated using the previous one in the array (or in the prior block if the array is empty). Note that this has implications on block size, and client memory requirements, though on expectation, the `Tickets` array should only contain one Ticket. Put another way, each Ticket should be generated from the prior one in the ticket-chain.

Succinctly, the process of verifying a block's tickets is as follows.
```text
Input: received block, storage market actor S, miner's public key PK, a public VDF validation key vk
Output: 0, 1

0. Get the tickets
    i. tickets <-- block.tickets
For each ticket, idx: tickets
1. Verify its VRF Proof
    i. # get the appropriate parent
        if idx == 0:
            # the first was derived from the prior block's last ticket
            parent = parentBlock.lastTicket
        else:
            parent = tickets[idx - 1]
    ii. # generate the VRFInput
        input <-- VRFPersonalization.Ticket | parent.VDFOutput
    iii. # verify the VRF
        VRFState <-- ECVRF_Verify(PK, ticket.VRFProof, input)
        if VRFState == "INVALID":
            return 0
2. Verify its VDF Proof
    i. # generate the VDF input
        VRFOutput <-- ECVRF_proof_to_hash(ticket.VRFProof)
    ii. # verify
        VDFState <-- VDF_verify(vk, VRFOutput, ticket.VDFOutput, ticket.VDFProof)
        if VDFState == "NO":
            return 0
3. Return results
    return 1
```

Notice that there is an implicit check that all tickets in the `Tickets` array are signed by the same miner.

### Election Validation

For election proof generation, see [checking election results](expected-consensus.md#checking-election-results).

In order to determine that the mined block was generated by an elegible miner, one must check its `ElectionProof`.

Succinctly, the process of verifying a block's election proof at round N, is as follows.

```text
Input: received block, storage market actor S, miner's public key PK, a public parameter K
Output: 0, 1

0. Get the election proof, total power, miner power
        i. electionProof <-- block.electionProof
        ii. # get total market power
            S <-- storageMarket(N)
            p_n <-- S.GetTotalStorage()
        iii. # get miner power
            p_m <-- GetMinersPowerAt(N, PK)
1. Ensure the miner was not slashed or late: in that case, their power would be 0 and can just abort.
        i. # Check for a reported fault or late submission
            if p_m == 0
                return 0
2. Determine the miner's power fraction
        i. # Get power fraction
              p_f <-- p_m/p_n
3. Ensure that the scratched ticket is a winner
        i. # get the deterministic output from the election proof
            VRFOutput <-- ECVRF_proof_to_hash(electionProof.VRFProof)
        ii. # map p_f onto [0, 2^HashLen]
            normalized_power <-- p_f * 2^HashLen
          iii. # Compare the miner's scratchValue to the miner's normalized power fraction
              if readLittleEndian(VRFOutput) > normalized_power:
                return 0
4. Get the appropriate ticket from the ticket chain
        i. # Get the tipset K rounds back
            appropriateTipset <-- lookback(K)
        ii. # Take its min ticket (already validated)
            scratchedTicket <-- appropriateTipset.minTicket()
5. Verify Election Proof validity
        i. # generate the VRFInput from the scratched ticket
            input <-- VRFPersonalization.ElectionProof | scratchedTicket.VDFOutput
        ii. # Check that the election proof was correctly generated by the miner
            # using the appropriate ticket
            VRFState <-- ECVRF_Verify(miner.PK, electionProof.VRFProof, input)
            if VRFState == "INVALID":
                return 0
5. Everything checks out, it's a valid election proof
        return 1
```


### ChainTipsManager

The Chain Tips Manager is a subcomponent of Filecoin consensus that is technically up to the implementer, but since the pseudocode in previous sections reference it, it is documented here for clarity.

The Chain Tips Manager is responsible for tracking all live tips of the Filecoin blockchain, and tracking what the current 'best' tipset is.

```go
// Returns the ticket that is at round 'r' in the chain behind 'head'
func TicketFromRound(head Tipset, r Round) {}

// Returns the tipset that contains round r (Note: multiple rounds' worth of tickets may exist within a single block due to losing tickets being added to the eventually successfully generated block)
func TipsetFromRound(head Tipset, r Round) {}

// GetBestTipset returns the best known tipset. If the 'best' tipset hasn't changed, then this
// will return the previous best tipset.
func GetBestTipset()

// Adds the losing ticket to the chaintips manager so that blocks can be mined on top of it
func AddLosingTicket(parent Tipset, t Ticket)
```
