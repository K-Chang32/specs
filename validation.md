## Chain Validation

Every filecoin full node must receive and process blocks from the network to ensure that they always know the correct latest state of the chain. How blocks get propogated through the network is discussed in the [Data Propogation](data-propagation.md) document.

Every block that comes in over the network must first be validated structurally. This starts with making sure it unmarshals correctly (see [block](data-structures.md#block)), making sure that all the fields contain legal values, and that the signature over the block is correct. Then, the consensus rules for the block must be validated. These include:

- The blocks parent tipset is valid, meaning that each parent:
  - Is a valid block
  - Is the same height as the others
  - Has the same parent tipset as the others
- The block's ticket is correctly generated:
  - Is generated from the smallest ticket in the parent tipset
  - If it includes intermediary failed tickets (i.e. null blocks) in the ticket array, that each ticket correctly generates the next in the array
  - That all tickets in the ticket array were generated by the same miner
  - The ticket is a winning ticket
- The state transitions are done correctly:
  - All messages are valid
  - Each message executes correctly and produces a receipt matching the corresponding one in the receipt set
    - For more information on message execution, see [the state machine spec](state-machine.md).
  - After all messages are applied, the resultant state root matches the one in the block

Once the block passes validation, it should be added to the local datastore, even in the case where we don't accept it right now. Future blocks from other miners may be mined on top of it and in that case we will want to have it around to avoid refetching. Blocks a certain distance from the current chain height may be dropped (exact number TBD, but blocks that havent been included after several days may be purged).

To make certain validation checks simpler, blocks should be indexed by height and by parent set. That way sets of blocks with a given height and common parents may be quickly queried. It may also be useful to compute and cache the resultant aggregate state of blocks in these sets, this saves extra state computation when checking which state root to start a block at when it has multiple parents.
