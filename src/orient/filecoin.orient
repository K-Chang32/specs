Assumptions:
  CID [CRH]:
    declare(cid_size, bytes)
    cid_size = 32 + 1 + 1 + 1

  SLE [VRF]:
    declare(vrf_proof_size) // TODO

Primitives:
  declare(var_int, bytes)
  varint = 4
  u64 = 8
  Dimensions:
    Size:
      kb = 1000
      mb = 1000 * kb
      gb = 1000 * mb
      tb = 1000 * gb
      pb = 1000 * tb
      ex = 1000 * pb
    Time:
      year_in_seconds = 365.25 * 24 * 60 * 60


VDFRSA:
  declare(rsa_element, bytes)
  rsa_element = (2048/8)

Blockchain:
  declare(block_time, seconds)
  Address:
    address_size = cid_size

  Block:
    block_framing_size = block_header_size + messages_size + receipts_size

    Messages:
      declare(messages, integer) // TODO
      messages_size = messages * message_size
      messages_root_cid = cid_size

      Message:
        message_size = to_address + from_address + message_nonce + value + gas_price + gas_limit + actor_method
        to_address = address_size
        from_address = address_size
        declare(message_nonce, bytes) // TODO
        message_nonce = varint
        declare(value, bytes)
        value = u64
        declare(gas_price, bytes)
        gas_price = u64
        declare(gas_limit, bytes)
        gas_limit = u64
        declare(actor_method, bytes) // TODO: actor_method what is it? how big is it?
        actor_method = u64

    Receipts:
      message_receipts_cid = cid_size
      Receipt:
        message_receipt = exit_code + return + gas_used
        declare(exit_code, bytes) // TODO
        exit_code = varint
        declare(return, bytes) // TODO
        return = varint
        declare(gas_used, bytes) // TODO
        gas_used = u64

    BlockHeader (EC):
      declare(block_header_size, bytes)
      assume(block_header_size > 0)
      assume(block_header_size < 1024*1024*10) // assume max is 10MB

      block_header_size = block_header_fixed_size + block_header_variable_size
      block_header_fixed_size = miner_address_size + election_proof_size + parent_weight_size + block_height_size + state_root_cid + messages_root_cid + bls_agg_size + message_receipts_cid + timestamp_size + block_sig_size
      block_header_variable_size = tickets_size + parents_cids

      StateTree:
        state_root_cid = cid_size

      Weight:
        declare(parent_weight_size, bytes) // TODO
        parent_weight_size = u64

      Height:
        declare(block_height_size, bytes) // TODO
        block_height_size = u64

      MinerAddress [CID]:
        miner_address_size = address_size

      ElectionProof (VRFBls) [SLE, BLSSig]:
        declare(election_proof_size, bytes) // TODO
        election_proof_size = 64

      // ElectionProof (VRFSecpk) [SLE, Secpk]:
      //   declare(election_proof_size, bytes) // TODO
      //   election_proof_size = 80

      Parents [CID]:
        declare(parents, integer) // TODO
        parents = expected_winning_miners
        parents_cids = parents * cid_size

      BLSSignatures (BLSSigAgg) [BLSSigAgg]:
        declare(bls_agg_size, bytes) // TODO
        bls_agg_size = 96

      Timestamp:
        declare(timestamp_size, integer) // TODO
        timestamp_size = u64

      // BlockSig (BlockSigSecpk):
         declare(block_sig_size, integer) // TODO
      //    block_sig_size = 80

      BlockSig (BlockSigBls):
        declare(block_sig_size, integer) // TODO
        block_sig_size = 96

      Tickets:
        declare(tickets_size, bytes)
        declare(tickets, integer)
        tickets_size = ticket_size * tickets
        ticket_size = election_proof_size + vdf_proof_size + vdf_output_size

SNARK [SNARKAssumptions]:
  declare(snark_single_proof_size, bytes)
  snark_single_proof_size = 192
  snark_max_constraints = 100000000

// VDF (VDFStorageBased):
//   vdf_proof_size = (vdf_snark_circuit / snark_max_constraints) * snark_single_proof_size
//   vdf_output_size = hash_size

VDF (VDFRSA):
  vdf_proof_size = 3 * rsa_element
  vdf_output_size = 0

Proofs:
  ProofOfReplication (ZigZag):
    Graph:
      declare(node_size, integer)
      declare(sector_size, integer)
      declare(nodes, integer)
      nodes = sector_size / node_size
      degree = degree_base + degree_expander
      sector_size_gb = sector_size / gb

      DRG (DRSample) [DRGAssumption]:
        declare(degree_base, integer)
        drg_e = 0.80
        drg_d = 1/4

      ExpanderParents (Chung) [ChungAssumption]:
        declare(degree_expander, integer)

      Layers:
//        declare(layers, integer)
        assume(layers > 0)
        layers = 2 * log2(1 / (3 * (epsilon -2 * delta))) + 2 * (0.8 - epsilon + delta)/(0.12 -2 * delta) + 2 // TODO should be >=

    SpaceGap:
      assume(spacegap > 0)
      assume(spacegap < 0.5)
      spacegap = epsilon + 2 * delta
      epsilon = - 3 * delta + 0.24 // was epsilon + 3 * delta < 0.24

    Soundness:
      declare(lambda, integer)
      assume(soundness > 0)
      assume(soundness < 0.5)
      soundness = 1/(2^lambda)

    Challenges:
      OfflineChallenges:
//        declare(offline_challenges, integer)
        declare(offline_challenges_all, integer)
        assume(offline_challenges > 0)
        offline_challenges = - lambda / (log2(2 - epsilon - 3  * delta) -1) // TODO should be >=

      OnlineChallenges:
        // declare(online_challenges, integer)
        assume(online_challenges > 0)
        online_challenges = log2(1/(3 *(epsilon - 2 * delta))) // TODO should be >=


    Seal:
      Encoding [KDFTiming]:
        assume(kdf_content > 0)
        assume(encoding_time > 0)
        assume(polling_time > 0)
        kdf_content = degree + 1
        encoding_time = layers * nodes * (kdf_content * node_size) * kdf_hash_time
        malicious_encoding = encoding_time / encoding_amax
        polling_time = malicious_encoding * drg_d

      Commitment (ZigZagCommitment) [CRH]:
        commit_size = cid_size
        assume(replica_commit_time > 0)
        replica_commit_time = commit_time * 3 + leaf_time * nodes
        seal_commitments_size = commit_size * 2 // 1 commD, 1 CommR

      ProofGeneration (ZigZagCommitment):
        assume(opening_time > 0)
        opening_per_challenge = degree_base + 2 * degree_expander + 1
        openings = offline_challenges * opening_per_challenge

        Leaf:
          leaf_constraints =  layers * leaf_hash_constraints
          leaf_circuit_time = layers * leaf_hash_circuit_time
          leaf_time = layers * leaf_hash_time

        Inclusion (MerkleVC) [CRH]:
//          declare(tree_depth, integer)
          tree_depth = log2(nodes)
          inclusion_circuit_time = tree_depth * merkle_hash_time_circuit
          inclusion_constraints = tree_depth * merkle_hash_constraints
          commit_time = nodes * merkle_hash_time

        SNARK [SNARKAssumptions]:

          comm_d_openings = degree_base + 2
          comm_d_time = offline_challenges * (comm_d_openings * inclusion_circuit_time + leaf_circuit_time)
          comm_d_constraints = offline_challenges * (comm_d_openings * inclusion_constraints + leaf_constraints)

          comm_r_openings = degree_base+degree_expander + 2
          comm_r_time = offline_challenges * (comm_r_openings * inclusion_circuit_time + leaf_circuit_time)
          comm_r_constraints = offline_challenges * (comm_r_openings * inclusion_constraints + leaf_constraints)

          comm_c_openings = (degree_base + 2 * degree_expander + 1)
          comm_c_time = offline_challenges * (comm_c_openings * inclusion_circuit_time + leaf_circuit_time)
          comm_c_constraints = offline_challenges * (comm_c_openings * inclusion_constraints + leaf_constraints)

          porep_snark_time = comm_d_time + comm_r_time + comm_c_time
          porep_snark_constraints = comm_d_constraints + comm_r_constraints + comm_c_constraints

          porep_snark_partitions = porep_snark_constraints / snark_max_constraints
          declare(snark_single_proof_size, bytes)
          porep_snark_proof_size = porep_snark_partitions * snark_single_proof_size

          proofgen_time = porep_snark_time

      Size:
        seal_proof_size = porep_snark_proof_size + seal_commitments_size

      Time:
        seal_time = replica_commit_time + proofgen_time + encoding_time
        parallel_seal_time = (porep_snark_time + commit_time)/cores + encoding_time
        declare(unseal_time) // TODO

      Cost:
        seal_cost = seal_time * (cpu_cost_per_second + memory_cost_per_second)
        declare(unseal_cost) // TODO


  ProofOfSpacetime:
    Randomness [RandomBeacon]:
      declare(post_randomness_lookback)

    Parameters:
      declare(proving_period_time)
      declare(max_proving_sectors)

  ProofOfSpacetime (RationalPoSt):
    Parameters:
      post_challenges = online_challenges

    Cost:
      declare(post_proving_cost)

    SNARK:
      post_snark_circuit = online_challenges * inclusion_constraints

    Size:
      post_proof_size = post_snark_proof_size
      post_snark_proof_partitions = 1 // TODO post_snark_circuit / snark_max_constraints
      post_snark_proof_size = post_snark_proof_partitions * snark_single_proof_size


  Consensus [ProofOfReplication, ProofOfSpacetime]:
    declare(expected_winning_miners, integer)
    declare(finality_height, integer)
    Tickets:
      tickets = avg_tickets
      avg_tickets = 1
      min_tickets = 0
      max_tickets = log(one_block_in_ten_years)/log(0.36) + 1 // 0.36^(max_tickets-1) = one_block_in_ten_years
      blocks_in_a_year = (year_in_seconds / block_time) * expected_winning_miners
      blocks_in_ten_years = blocks_in_a_year * 10
      one_block_in_ten_years = 1/blocks_in_ten_years

Mining:
  declare(power_table_lookback)
  declare(slashing_post_time)
  declare(reseal, integer)

  seals_per_sector_per_year = reseal+1
  posts_per_sector_per_year = year_in_seconds / proving_period_seconds
  OnChainFootprint:
    proving_period_seconds = proving_period_hours * 60 * 60
    seals_size_per_sector_per_year = seals_per_sector_per_year * seal_proof_size
    posts_size_per_sector_per_year = posts_per_sector_per_year * post_proof_size
    proofs_size_per_sector_per_year = seals_size_per_sector_per_year + posts_size_per_sector_per_year
    messages_per_sector_per_year = seals_per_sector_per_year + posts_per_sector_per_year
    // assert(proofs_messages_per_year * )

  StorageMarket:
    declare(min_storing_time)

NetworkGoals:
  DataPropagation: // TODO some network assumptions here
    // block_time = ...
    // block_framing_size = ...
    declare(block_propagation_time)
    declare(block_delay)

ScalingRequirements:
  declare(max_storage_network_capacity_year)
  declare(seal_time)
  declare(unseal_time)
  declare(max_network_throughput_year)

  StorageCapacity:
    max_storage_network_capacity_year = 10 * ex
    max_sectors = max_storage_network_capacity_year / sector_size

    max_proofs_size_per_year = proofs_size_per_sector_per_year * max_sectors
    max_proofs_messages_per_year = messages_per_sector_per_year * max_sectors

    proofs_size_per_block = max_proofs_size_per_year / blocks_in_a_year
    proofs_messages_per_block = max_proofs_messages_per_year / blocks_in_a_year

    block_size = block_framing_size + proofs_size_per_block
    messages = proofs_messages_per_block + tx_messages_per_block + actors_messages_per_block // TODO

    // TODO deal

EconomicsRequirements:
  declare(seal_cost)
  declare(unseal_cost)
  declare(year_mining_reward)
  declare(min_hardware_cost)
