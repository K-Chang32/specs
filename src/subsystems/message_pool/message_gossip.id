

// MessageGossip is a component of the MessagePool. It is in charge of receiving and
// propagating Messages. It a libp2p pubsub protocol.
type MessageGossip struct {
	/*
	// PropagateMessages is called to send out a set of messages to the rest of the
	// network. This is used for messages added locally.
	PropagateMessages([Message])

	// NewMessageReceived is a channel that returns message objects as they arrive.
	// It is a notification for MessageGossip's client (usually the MessagePool).
	NewMessageReceived() MessageChan

	pubsub pubsub.PubSub
	sub    *pubsub.Subscription
	mchan  MessageChan
	*/
}

var FilecoinVMMessageTopic = "/filecoin.org/messages"

func NewMessageGossip(ps libp2p.PubSub) (mg *MessageGossip) error {
	/*
	// TODO: address validation + bad message suppression.
	val := nil
	sub, err := ps.Subscribe(FilecoinVMMessageTopic, val)
	if err != nil {
		return nil, err
	}

	mch := new(MessageChan)
	mg := &MessageGossip{ps, sub, mch}

	// TODO: how will he handle things like this in the spec?
	// this is an idiomatic thing, BUT we do need to address asynchrony in the spec somehow.
	go mg.handleIncoming()

	return mg
	*/
}

func (mg *MessageGossip) PropagateMessages(msgs [Message]) {
	/*
	// msgs is most likely to be completely new messages that nobody has.
	// sometimes not. if we think it's really a problem, deal with it then.
	buf := serialize(msgs)
	mg.pubsub.Publish(FilecoinVMMessageTopic, buf)
	*/
}

func (mg *MessageGossip) handleIncoming() {
	/*
	for {
		m, err := mg.sub.Next()
		if err != nil {
			return // done
		}
		m.NewMessageReceived <- m
	}
	*/
}
