/*
type StorageDealID BigInt

type StorageDeal struct {
	ID StorageDealID
	Provider Address
	Client Address
	StartTime	Epoch
	Duration UVarint
	StorageCollateral UVarint
}

type StorageProviderInfo struct {
	Address Address
	Balance BigInt
	FreeCapacity BigInt
	Collateral BigInt
	BlackList [CID] // list of contents that providers reject
}

type StorageMarketSubsystem struct {
	// need access to:
	// - DataTransferSubsystem
	//   - transfer data
	// - BlockchainSubsystem
	//   - needs access to StateTree 
	//     to verify storage capacity and pledge amount
	//     and slash storage providers for storage faults
	// 	 - needs access to access to MessagePool if deals on chain
	// - NetworkSubsystem
	//   - needs access to MessagePubsub

	// Assumption: Market Making is off chain
	// 			   Storage deals are on chain
	ActiveDeals() {StorageDealID:StorageDeal}

	// AddNewStorageDeal is called to add storage deal
	// potentially a storage market actor is called
	// to include the storage deal
	AddNewStorageDeal(StorageDeal) bool

	// RemoveStorageDeal is called to remove storage deal
	// from chain by calling the storage market actor
	RemoveStorageDeal(StorageDealID) bool

	// ExtendStorageDeal is called to extend the duration
	// of a storage deal by depositing FIL tokens into a
	// storage deal
	ExtendStorageDeal(StorageDealID, TokenAmount) bool

	// VerifyStorageProvider is called to retrieve information
	// about a storage provider as verified by the blockchain
	VerifyStorageProvider(Address) StorageProviderInfo

	// SlashStorageProvider is called to slash a provider
	// for violating a storage deal
	SlashStorageProvider(StorageDealID) bool



	// Assumption: Market Making is on chain
	type Price UVarint
	// this can be potentially changed to an enum
	type StorageQuality struct {
		BlackList [CID]
		Availability BigInt // integer representation of percentage
		RetrievalTime BigInt // denoted in milliseconds
	}

	type UnitStorageCommodity struct {
		// for example, 1TB/hour of highly available data
		UnitSize UVarint // should be made a constant
		UnitDuration UVarint // should be made a constant
		Quality StorageQuality
	}

	// type StorageCommodity struct {
	// 	Quantity UVarint
	// 	Storage UnitStorageCommodity
	// }

	type MarketSide union {
		| Bid
		| Ask
	} 

	type StorageMarketOrder struct {
		Side MarketSide
		Price BigInt
		Quantity BigInt
	}

	type StorageMarketOrderBook struct {
		Grade UnitStorageCommodity
		Bids PQueue(StorageMarketOrder)
		Asks PQueue(StorageMarketOrder)
	}
	
	StorageMarkets() {UnitStorageCommodity:StorageMarketOrderBook}
	GetStorageMarketForCommodity(UnitStorageCommodity) StorageMarketOrderBook

	// for simplicity, no distinction between limit and market orders
	AddBid(UnitStorageCommodity, StorageMarketOrder)
	AddAsk(UnitStorageCommodity, StorageMarketOrder)

}
*/
