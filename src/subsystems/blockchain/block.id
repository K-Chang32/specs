/*
type Block struct {
	MinerAddress()               Address
	Tickets()                    []Ticket
	ParentTipset()               Tipset
	ParentWeight()               BlockWeight
	Height()                     Word
	StateTree()                  StateTree
	Messages()                   []Message
//	BLSAggregate()               Signature
// 	MessageReceipts()            []MessageReceipt
//	Timestamp()                  Timestamp
//	BlockSig()                   Signature

//	SerializeSigned()            []byte
//	ComputeUnsignedFingerprint() []byte
}

type Tipset struct {
	Blocks            [Block]

    Has(Block)        bool
    Parents()         Tipset         @(cached)
	// StateTree should live in VM
	StateTree()       StateTree      @(cached)
    Epoch()           Epoch          @(cached)
    Weight()          ChainWeight    @(cached)

	ValidateSyntax()
}

type Ticket struct {
	VRFResult() VRFResult
	VDFResult() VDFResult
	VDFProof() 	VDFProof

	// Generate(k VRFKeyPair, seed ElectionSeed) Ticket
	ValidateSyntax() bool
}

type ElectionProof struct {
	VRFResult() VRFResult
	IsWinning(minerPower Fraction) bool	@(cached)

	ValidateSyntax() bool
}

////////////////////
// Implementation //
////////////////////

func (tix *Ticket) ValidateSyntax() bool {

	return VRFResult.validateSyntax() // TODO
		&& VDFResult.validateSyntax()
		&& VDFProof.validateSyntax()
}

func (ep *ElectionProof) ValidateSyntax() bool {
	return VRFResult.validateSyntax()
}

func (ts *Tipset) ValidateSyntax() bool {

    if !len(ts.Blocks) > 0 {
        return false
    }

	parents := ts.Parents()
	grandparent := parents[0].Parents()
    for i := 1; i < len(parents); i++ {
        if grandparent != parents[i].Parents() {
            return false
		}
	}

	numTickets := len(ts.Blocks[0].Tickets())
    for i := 1; i < len(ts.Blocks); i++ {
        if numTickets != len(ts.Blocks[i].Tickets()) {
            return false
		}
	}

	return true
}

func (tipset *TipsetI) StateTree() StateTree {
	var currTree StateTree = nil
	for _, block := range tipset.Blocks() {
		if currTree == nil {
			currTree = block.StateTree()
		} else {
			Assert(block.StateTree().CID().Equals(currTree.CID()))
		}
	}
	Assert(currTree != nil)
	for _, block := range tipset.Blocks() {
		currTree = UpdateStateTree(currTree, block)
	}
	return currTree
}

type BlockWeight BigInt

*/