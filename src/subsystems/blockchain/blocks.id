
type BlockStore struct {
    GetBlock(CID) Block
    PutBlock(Block) error
}

type Block struct {
	MinerAddress()               Address
	Tickets()                    []Ticket
	ParentTipset()               Tipset
	ParentWeight()               BlockWeight
	Height()                     Word
	StateTree()                  StateTree
	Messages()                   []Message
//	BLSAggregate()               Signature
// 	MessageReceipts()            []MessageReceipt
//	Timestamp()                  Timestamp
//	BlockSig()                   Signature

//	SerializeSigned()            []byte
//	ComputeUnsignedFingerprint() []byte
}


type Tipset struct {
	Blocks            [Block]

    Has(Block)        bool
    Parents()         Tipset         @(cached)
	StateTree()       StateTree      @(cached)
    Epoch()           Epoch          @(cached)
    Weight()          ChainWeight    @(cached)

	ValidateSyntax()
}

type Ticket struct {
	VRFResult() VRFResult
	VDFResult() VDFResult
	VDFProof() 	VDFProof

	// Generate(k VRFKeyPair, seed ElectionSeed) Ticket
	ValidateSyntax() bool
}

type ElectionProof struct {
	VRFResult() VRFResult
	IsWinning(minerPower Fraction) bool	@(cached)

	ValidateSyntax() bool
}

////////////////////
// Implementation //
////////////////////

func (tix *Ticket) ValidateSyntax() bool {
	
	return VRFResult.validateSyntax() // TODO
		&& VDFResult.validateSyntax()
		&& VDFProof.validateSyntax()
}

func (ep *ElectionProof) ValidateSyntax() bool {
	return VRFResult.validateSyntax()
}

func (ts *Tipset) ValidateSyntax() bool {

    if !len(ts.Blocks) > 0 {
        return false
    }

	parents := ts.Parents()
	grandparent := parents[0].Parents()
    for i := 1; i < len(parents); i++ {
        if grandparent != parents[i].Parents() {
            return false
		}
	}
	
	numTickets := len(ts.Blocks[0].Tickets())
    for i := 1; i < len(ts.Blocks); i++ {
        if numTickets != len(ts.Blocks[i].Tickets()) {
            return false
		}
	}

	return true
}

/**
type Message interface {
	To()        Address
	From()      Address
	Nonce()     Word
	Value()     BigInt
	GasPrice()  BigInt
	GasLimit()  BigInt
	Method()    Word
	Params()    []byte
}

type MessageReceipt interface {
	ExitCode()  byte
	Return()    []byte
	GasUsed()   BigInt
}


type BlockWeight BigInt

func (block *BlockI) ComputeUnsignedFingerprint() []byte {
	return Hash(HashRole_BlockSig, block.SerializeUnsigned());	
}

func (block *BlockI) SerializeUnsigned() []byte {
	panic("TODO")
}

func (block *BlockI) SerializeSigned() []byte {
	panic("TODO")
}

////////////////////
// Implementation //
////////////////////

type BlockI struct {
	minerAddress    Address
	tickets         []Ticket
	parentTipset    Tipset
	weight          BigInt
	height          Word
	stateTree       StateTree
	messages        []Message
	blsAggregate    Signature
	messageReceipts []MessageReceipt
	timestamp       Timestamp
	blockSig        Signature
}

func (block *BlockI) MinerAddress() Address {
	return block.minerAddress
}

func (block *BlockI) Tickets() []Ticket {
	return block.tickets
}

func (block *BlockI) ParentTipset() Tipset {
	panic("TODO")
}

func (block *BlockI) Weight() BlockWeight {
	panic("TODO")
}

func (block *BlockI) Height() Word {
	panic("TODO")
}

func (block *BlockI) StateTree() StateTree {
	panic("TODO")
}

func (block *BlockI) Messages() []Message {
	panic("TODO")
}

func (block *BlockI) BLSAggregate() Signature {
	return block.blsAggregate
}

func (block *BlockI) MessageReceipts() []MessageReceipt {
	return block.messageReceipts
}

func (block *BlockI) Timestamp() Timestamp {
	panic("TODO")
}

func (block *BlockI) BlockSig() Signature {
	panic("TODO")
}
**/