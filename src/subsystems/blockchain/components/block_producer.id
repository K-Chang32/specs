type BlockProducer struct {
	// ElectionProof() ElectionProof
	// Messages() [Message]

	// call by StorageMiningSubsystem when elected as a leader
	// a procedural call that calls GetMostProfitableMessages(minerAddr Address)
	// and then get back the messages and call AssembleBlock
	// TODO minerAddr is of type StorageMiner.Address
	GenerateBlock(electionProof ElectionProof, T0 Ticket, tipset Tipset, minerAddr Address) struct{}

	// call by BlockProducer itself after getting back messages
	AssembleBlock(electionProof ElectionProof, T0 Ticket, tipset Tipset, minerAddr Address, messages [Message]) Block
}

// type BlockStore struct {
//     GetBlock(CID) Block
//     PutBlock(Block) error
// }

/*

////////////////////
// Implementation //
////////////////////

func (miner *BlockProducer_I) MineBlock(messages []Message) Block {
	var chain = miner.Blockchain()
    T := chain.CurrentMiningEpoch()
    K := Param_ElectionLookback

    if T - K < 0 {
        panic("");  // TODO: handle genesis block
    }

	var parentTipset    = chain.TipsetAtEpoch(T)
	var lookbackTipset  = chain.TipsetAtEpoch(T - K)

	var currSeed = lookbackTipset.ElectionSeed()
    var currTicket Ticket
    var tickets []Ticket

    for {
        currTicket = Ticket.Generate(nil, miner.VRFKeyPair(), currSeed)
        tickets = append(tickets, currTicket)

        if currTicket.IsWinning(miner.PowerFraction()) {
			ret := &BlockI {
				minerAddress: miner.Address(),
				tickets:      tickets,
				parentTipset: parentTipset,
				weight:       ComputeBlockWeight(parentTipset, tickets),
				height:       T + 1,
				stateTree:    parentTipset.StateTree(),
				messages:     messages,
				timestamp:    CurrentTime(),
				blockSig:     nil,
			};
			ret.blockSig = miner.SigKeyPair().Sign(ret.ComputeUnsignedFingerprint())
			return ret
        }
    }
}

*/
