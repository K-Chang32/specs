type BlockProducer struct {
	ElectionProof() ElectionProof
	Messages() [Message]

	NewBestTipset(tipset Tipset) struct {}
	AssembleBlock(electionProof ElectionProof, messages [Message]) Block
}

type ElectionProof struct {}
type Message struct {}

type Block struct {
	//TODO can we group these better into subcomponents?
	// MinerAddress()               Address
	// Tickets()                    []Ticket
	// ElectionProof()              ElectionProof
	// ParentTipset()               Tipset
	// ParentWeight()               BlockWeight
	// Height()                     Word
	// StateTree()                  StateTree
	// Messages()                   []Message
//	BLSAggregate()               Signature
// 	MessageReceipts()            []MessageReceipt
//	Timestamp()                  Timestamp
//	BlockSig()                   Signature

//	SerializeSigned()            []byte
//	ComputeUnsignedFingerprint() []byte
}

// type BlockStore struct {
//     GetBlock(CID) Block
//     PutBlock(Block) error
// }

/*
type Tipset struct {
	Blocks            [Block]

    Has(Block)        bool
    Parents()         Tipset         @(cached)
	// StateTree should live in VM
	StateTree()       StateTree      @(cached)
    Epoch()           Epoch          @(cached)
    Weight()          ChainWeight    @(cached)

	ValidateSyntax() bool
}

type Ticket struct {
	VRFResult() VRFResult
	VDFResult() VDFResult
	VDFProof() 	VDFProof

	// Generate(k VRFKeyPair, seed ElectionSeed) Ticket
	ValidateSyntax() bool
}

type ElectionProof struct {
	VRFResult() VRFResult
	IsWinning(minerPower Fraction) bool	@(cached)

	ValidateSyntax() bool
}

////////////////////
// Implementation //
////////////////////

func (tix *Ticket) ValidateSyntax() bool {
	
	return VRFResult.validateSyntax() // TODO
		&& VDFResult.validateSyntax()
		&& VDFProof.validateSyntax()
}

func (ep *ElectionProof) ValidateSyntax() bool {
	return VRFResult.validateSyntax()
}

func (ts *Tipset) ValidateSyntax() bool {

    if !len(ts.Blocks) > 0 {
        return false
    }

	parents := ts.Parents()
	grandparent := parents[0].Parents()
    for i := 1; i < len(parents); i++ {
        if grandparent != parents[i].Parents() {
            return false
		}
	}
	
	numTickets := len(ts.Blocks[0].Tickets())
    for i := 1; i < len(ts.Blocks); i++ {
        if numTickets != len(ts.Blocks[i].Tickets()) {
            return false
		}
	}

	return true
}

func (miner *BlockProducer_I) MineBlock(messages []Message) Block {
	var chain = miner.Blockchain()
    T := chain.CurrentMiningEpoch()
    K := Param_ElectionLookback

    if T - K < 0 {
        panic("");  // TODO: handle genesis block
    }

	var parentTipset    = chain.TipsetAtEpoch(T)
	var lookbackTipset  = chain.TipsetAtEpoch(T - K)

	var currSeed = lookbackTipset.ElectionSeed()
    var currTicket Ticket
    var tickets []Ticket

    for {
        currTicket = Ticket.Generate(nil, miner.VRFKeyPair(), currSeed)
        tickets = append(tickets, currTicket)

        if currTicket.IsWinning(miner.PowerFraction()) {
			ret := &BlockI {
				minerAddress: miner.Address(),
				tickets:      tickets,
				parentTipset: parentTipset,
				weight:       ComputeBlockWeight(parentTipset, tickets),
				height:       T + 1,
				stateTree:    parentTipset.StateTree(),
				messages:     messages,
				timestamp:    CurrentTime(),
				blockSig:     nil,
			};
			ret.blockSig = miner.SigKeyPair().Sign(ret.ComputeUnsignedFingerprint())
			return ret
        }
    }
}

*/
