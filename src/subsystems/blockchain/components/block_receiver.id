
type ErrInvalidBlock error

type BlockReceiver struct {
    // Note: a Block uniquely identifies a tipset (the parents)
    // from here, we may consider many tipsets that _include_ Block
    // but we must indeed include it and not consider tipsets that
    // fork from Block.Parents, but do not include Block.
    LatestCheckpoint        *Block

    validationGraph         BlockValidationGraph
    validateBlockSyntax()   bool   
}

type BlockValidationGraph struct {
    // ValidatedBlocks contains all the blocks we have validated.
    // This means all the blocks connected into the main blockchain.
    ValidatedBlocks BlockStore

    // ValidationFringe is the set of unvalidated partial chains fully connected
    // to the validated blockchain. These are ready to be validated, and 
    // ordered by total ChainWeight. Their ancestors are all in either the
    // ValidationFringe or in the ValidatedBlocks
    ValidationFringe SubchainOrganizer

    // UnconnectedBlocks is the set of disconnected blocks, which
    // may or may not connect back to the growing blockchain. This set
    // could contain the heaviest chain, and could contain attackers'
    // blocks.
    UnconnectedBlocks AncestryGraph

    ConsiderBlock(Block) error
}

////////////////////
// Implementation //
////////////////////

func (g *BlockValidationGraph) ConsiderBlock(block Block) error {
    if ! block.CheapValidate() {
        return ErrInvalidBlock
    }

    g.UnconnectedBlocks.AddBlock(block)
    g.tryConnectBlockToFringe(block)
}

func (g *BlockValidationGraph) tryConnectBlockToFringe(block Block) {
    // try to connect the block, and then try connecting its descendents.
    //
    // this algorithm should be breadth-first because we need to process the fringe
    // in order. Depth-first search may consider blocks whose parents are still
    // yet to be added
    blocks := Queue<Block>
    blocks.Enqueue(block)
    for block := blocks.Dequeue() {
        if ! g.ValidationFringe.HasTipset(block.Parents()) {
            continue // ignore this one. not all of its parents are in fringe
        }

        children := g.UnconnectedBlocks.Children[block]
        g.UnconnectedBlocks.Parents.Remove(block)
        g.UnconnectedBlocks.Children.Remove(block)
        g.ValidationFringe.AddBlock(block)
        blocks.EnqueueAll(children)
    }
}

func validateBlockSyntax(block Block) {

    if !block.MinerAddress().VerifySyntax(StorageMinerActor.Address) {
        return false
    }

    if !(len(block.Tickets) > 0) {
        return false
    }

    for _, tix := range block.Tickets {
        if !tix.ValidateSyntax() {
            return false
        }
    }

    if !block.ElectionProof.ValidateSyntax() {
        return false
    }

    if !block.ParentTipset().validateSyntax() {
        return false
    }
    
    if !block.ParentWeight() > 0 {
        return false
    }

    if !block.Height() > 0 {
        return false
    }

    if !block.StateTree().ValidateSyntax() {
        return false
    }

    for _, msg := block.Messages() {
        if !msg.ValidateSyntax() {
            return false
        }
    }

    // TODO msg receipts

    // TODO timestamp

    // TODO Sig

    return true

}

// SubchainQueue keeps track of a set of blocks, organized into tipsets,
// and with a set of tipsets tracked and sorted by a function
type SubchainQueue struct {
    // Chains keeps subchains sorted to validate by chain weight
    Chains PQueue<Subchain>

    // ChainMembership provides efficient access from any block to the
    // Subchain in question
    ChainMembership {Block:Subchain}

    HasTipset(Block) // todo
    AddBlock(Block) // todo (recalc weights)
    RemoveTipset(Tipset)
}

type AncestryGraph struct {
    Parents {Block:Tipset}
    Children {Block:[Block]}
}

type Subchain struct {
    Head    Tipset
    Tail    Tipset
    Weight  ChainWeight
    Tipsets {Block:Tipset}
}

