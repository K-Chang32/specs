// type BlockStore struct {
//     GetBlock(CID) Block
//     PutBlock(Block) error
// }

type BlockProducer struct {
	ElectionProof() ElectionProof
	Messages() [Message]

	OnNewBestTipset(tipset Tipset) struct {}

	TryLeaderElection (scratchedTicket [Ticket])
	AssembleBlock(electionProof ElectionProof, messages [Message]) Block
}

type ElectionProof struct {}
type Message struct {}

// type SignedBlock struct {
// 	UnsignedBlock Block
// 	BlockSig Signature
// }




type Block struct {
	//TODO can we group these better into subcomponents?
	MinerAddress()               Address
	Tickets()                    []Ticket
	ElectionProof()              ElectionProof
	ParentTipset()               Tipset
	ParentWeight()               BlockWeight
	Height()                     Word
	StateTree()                  StateTree
	Messages()                   []Message
//	BLSAggregate()               Signature
// 	MessageReceipts()            []MessageReceipt
//	Timestamp()                  Timestamp
//	BlockSig()                   Signature

//	SerializeSigned()            []byte
//	ComputeUnsignedFingerprint() []byte
}

/*
type Tipset struct {
	Blocks            [Block]

    Has(Block)        bool
    Parents()         Tipset         @(cached)
	// StateTree should live in VM
	StateTree()       StateTree      @(cached)
    Epoch()           Epoch          @(cached)
    Weight()          ChainWeight    @(cached)

	ValidateSyntax() bool
}

type Ticket struct {
	VRFResult() VRFResult
	VDFResult() VDFResult
	VDFProof() 	VDFProof

	// Generate(k VRFKeyPair, seed ElectionSeed) Ticket
	ValidateSyntax() bool
}

type ElectionProof struct {
	VRFResult() VRFResult
	IsWinning(minerPower Fraction) bool	@(cached)

	ValidateSyntax() bool
}

////////////////////
// Implementation //
////////////////////

func (tix *Ticket) ValidateSyntax() bool {
	
	return VRFResult.validateSyntax() // TODO
		&& VDFResult.validateSyntax()
		&& VDFProof.validateSyntax()
}

func (ep *ElectionProof) ValidateSyntax() bool {
	return VRFResult.validateSyntax()
}

func (ts *Tipset) ValidateSyntax() bool {

    if !len(ts.Blocks) > 0 {
        return false
    }

	parents := ts.Parents()
	grandparent := parents[0].Parents()
    for i := 1; i < len(parents); i++ {
        if grandparent != parents[i].Parents() {
            return false
		}
	}
	
	numTickets := len(ts.Blocks[0].Tickets())
    for i := 1; i < len(ts.Blocks); i++ {
        if numTickets != len(ts.Blocks[i].Tickets()) {
            return false
		}
	}

	return true
}
*/
