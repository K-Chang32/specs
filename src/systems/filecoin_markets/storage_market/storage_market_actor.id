// Assumptions:
//    - Deals are on Chain 
//    - Storage Payment is done on PoSt submission
//    - Updatable Filecoin Storage Deals (Not in current version)

// Miners can pledge and commit sectors and participate
// in expected consensus to earn block rewards
// However, block rewards earned are vested for a year
// over an exponentially increasing schedule
// meaning that miners can only withdraw all of their
// block rewards from mining a particular block after a year

// The goals of the storage market subsystem are thus to
// 1) facilitate deal addition to an existing sector
// 2) update existing deal 

// A clean separation of concern is also resulted
// pledgeCollateral is now solely for consensus and pledging storage
// storageDealCollateral is for each deal and up to the transacting parties
// In the event that miners do not add deals to a sector,
// full block rewards are earned after maintaining that sector for a year

import base "github.com/filecoin-project/specs/systems/filecoin_markets"

type StorageDeal   base.StorageDeal
type StorageDealID base.StorageDealID
type TokenAmount   base.TokenAmount
type Address       base.Address

type StorageParticipantBalance struct {
  Locked    TokenAmount
  Available TokenAmount
}

type StorageMarketActor struct {
  // need access to:
  // - DataTransferSubsystem
  //   - transfer data
  // - BlockchainSubsystem
  //   - needs access to StateTree
  //     to verify storage capacity and pledge amount
  //     and slash storage providers for storage faults
  //    - needs access to access to MessagePool if deals on chain
  // - NetworkSubsystem
  //   - needs access to MessagePubsub

  ParticipantBalances { Address : StorageParticipantBalance }
  StorageDeals { StorageDealID : StorageDeal }

  RegisterParticipant(lockedBalance TokenAmount) bool
  WithdrawBalance(balance TokenAmount) struct {}
  AddBalance(balance TokenAmount) struct {}
  CheckLockedBalance(participantAddr Address) TokenAmount

  // TODO: There should be some punishment for publishing a deal too late
  // call by countersigner or CommitSector
  PublishStorageDeal(newStorageDeal StorageDeal) struct {}

  // TODO: StorageDeals should be renewable
  UpdateStorageDeal(newStorageDeal StorageDeal) struct {}

  // call by CronActor on ExpiredSet
  CloseExpiredStorageDeal(targetStorageDeal StorageDeal) struct {}

  // call by StorageMarketActor or CronActor to slash deal collateral
  SlashStorageDealCollateral(targetStorageDeal StorageDeal) struct {}

}
