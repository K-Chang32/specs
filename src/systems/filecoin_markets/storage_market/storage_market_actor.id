import actor "github.com/filecoin-project/specs/systems/filecoin_vm/actor"
import addr "github.com/filecoin-project/specs/systems/filecoin_vm/actor/address"
import block "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block"
import base_markets "github.com/filecoin-project/specs/systems/filecoin_markets"

type StorageDeal base_markets.StorageDeal
type StorageDealID base_markets.StorageDealID

type StorageParticipantBalance struct {
    Locked     actor.TokenAmount
    Available  actor.TokenAmount
}

type PublishStorageDealSuccess struct {
    DealCID deal.DealCID
}
type PublishStorageDealError struct {}
type PublishStorageDealResponse struct {
    Success  PublishStorageDealSuccess
    Error    PublishStorageDealError
}

type StorageMarketActor struct {
    // need access to:
    // - DataTransferSubsystem
    //   - transfer data
    // - BlockchainSubsystem
    //   - needs access to StateTree
    //     to verify storage capacity and pledge amount
    //     and slash storage providers for storage faults
    //    - needs access to access to MessagePool if deals on chain
    // - NetworkSubsystem
    //   - needs access to MessagePubsub

    ParticipantBalances  {addr.Address: StorageParticipantBalance}
    StorageDeals         {StorageDealID: StorageDeal}

    RegisterParticipant(lockedBalance actor.TokenAmount) bool
    WithdrawBalance(balance actor.TokenAmount)
    AddBalance(balance actor.TokenAmount)
    CheckLockedBalance(participantAddr addr.Address) actor.TokenAmount

    // TODO: There should be some punishment for publishing a deal too late
    // call by CommitSector in StorageMiningSubsystem
    // a StorageDeal is only published on chain when it passes VerifyStorageDeal
    PublishStorageDeal(newStorageDeal deal.StorageDeal) PublishStorageDealResponse

    // check if StorageDeal is still valid
    // check if StorageDeal has the right signature
    // check if provider and client have sufficient balances
    VerifyStorageDeal(newStorageDeal deal.StorageDeal) bool

    // TODO: StorageDeals should be renewable
    UpdateStorageDeal(newStorageDeal deal.StorageDeal)

    // call by StorageMarketActor on ExpiredSet
    // remove StorageDeal from StorageMarketActor
    // return StorageCollateral to miners
    CloseExpiredStorageDeal(targetStorageDeal deal.StorageDeal)

    // call by StorageMinerActor on successful PoSt Submission
    HandleStorageDealPayment(storageDeal StorageDeal, currEpoch block.ChainEpoch)

    // call by StorageMinerActor or CronActor to slash deal collateral
    SlashStorageDealCollateral(targetStorageDeal deal.StorageDeal)
}
