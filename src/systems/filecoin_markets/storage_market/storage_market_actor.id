import actor "github.com/filecoin-project/specs/systems/filecoin_vm/actor"
import addr "github.com/filecoin-project/specs/systems/filecoin_vm/actor/address"
import block "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block"
import deal "github.com/filecoin-project/specs/systems/filecoin_markets/deal"

type StorageDeal base_markets.StorageDeal
type StorageDealID base_markets.StorageDealID

type StorageParticipantBalance struct {
    Locked     actor.TokenAmount
    Available  actor.TokenAmount
}

type PublishStorageDealSuccess struct {
    DealID   deal.DealID
    DealCID  deal.DealCID
}
type PublishStorageDealError struct {}
type PublishStorageDealResponse struct {
    Success  PublishStorageDealSuccess
    Error    PublishStorageDealError
}

type StorageMarketActor struct {
    // need access to:
    // - DataTransferSubsystem
    //   - transfer data
    // - BlockchainSubsystem
    //   - needs access to StateTree
    //     to verify storage capacity and pledge amount
    //     and slash storage providers for storage faults
    //    - needs access to access to MessagePool if deals on chain
    // - NetworkSubsystem
    //   - needs access to MessagePubsub

    Balances  {base_blockchain.Address: StorageParticipantBalance}
    Deals     {deal.DealID: deal.StorageDeal}

    WithdrawBalance(balance deal.TokenAmount)
    AddBalance(balance deal.TokenAmount)
    CheckLockedBalance(participantAddr base_blockchain.Address) deal.TokenAmount

    // call by CommitSector in StorageMiningSubsystem
    // a StorageDeal is only published on chain when it passes verifyStorageDeal
    // a DealID will be assigned and stored in the mapping of DealID to StorageDeal
    // PublishStorageDeal should be called before SecotrCommits
    // an unregistered StorageDeal will not be processed
    PublishStorageDeal(newStorageDeals [deal.StorageDeal]) [PublishStorageDealResponse]

    // check if StorageDeal is signed before expiry
    // check if StorageDeal has the right signatures
    // check if provider and client have sufficient balances
    verifyStorageDeal(newStorageDeal deal.StorageDeal) bool

    // generate storage deal id
    generateStorageDealID(storageDeal deal.StorageDeal) deal.DealID

    // TODO: StorageDeals should be renewable
    // UpdateStorageDeal(newStorageDeals [deal.StorageDeal])

    // call by CronActor on PoSt submission
    // trigger subsequent calls on different SectorSet
    // pull SectorSet from the run time
    HandleCronAction()

    // call by CronActor on ExpiredSet
    // remove StorageDeal from StorageMarketActor
    // if no more active deals contain in the sector
    // adjust miner power for this sector
    // return StorageCollateral to miners
    closeExpiredStorageDeal(storageDealIDs [deal.DealID])

    // call by CronActor on ActiveSet to process deal payment
    // go through StorageDealIDs, if IDs are active in MarketActor
    // payment will be processed
    handleStorageDealPayment(storageDealIDs [deal.DealID], currEpoch base_blockchain.Epoch)

    // call by CronActor on FaultSet to slash deal collateral
    slashStorageDealCollateral(storageDealIDs [deal.DealID])
}
