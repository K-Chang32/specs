import actor "github.com/filecoin-project/specs/systems/filecoin_vm/actor"
import actor_util "github.com/filecoin-project/specs/systems/filecoin_vm/actor_util"
import address "github.com/filecoin-project/specs/systems/filecoin_vm/actor/address"
import block "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block"
import deal "github.com/filecoin-project/specs/systems/filecoin_markets/deal"
import filcrypto "github.com/filecoin-project/specs/algorithms/crypto"
import libp2p "github.com/filecoin-project/specs/libraries/libp2p"
import sealing "github.com/filecoin-project/specs/systems/filecoin_mining/sector"
import sector "github.com/filecoin-project/specs/systems/filecoin_mining/sector"

type MinerPoStState union {
    OK struct {
        LastSuccessfulPoSt block.ChainEpoch
    }

    Challenged struct {
        SurpriseChallengeEpoch  block.ChainEpoch
        NumConsecutiveFailures  int
    }

    Failing struct {
        NumConsecutiveFailures int
    }
}

type SectorState enum {
    PreCommit
    Active
    TemporaryFault
}

type SectorOnChainInfo struct {
    State                       SectorState
    Info                        sealing.SectorPreCommitInfo
    PreCommitDeposit            actor.TokenAmount
    PreCommitEpoch              block.ChainEpoch
    ProveCommitEpoch            block.ChainEpoch  // -1 if still in PreCommit state.
    DeclaredFaultEpoch          block.ChainEpoch  // -1 if not currently declared faulted.
    DeclaredFaultDuration       block.ChainEpoch  // -1 if not currently declared faulted.
    DealWeight                  BigInt  // -1 if not yet validated with StorageMarketActor.

    // Must be significantly larger than DeclaredFaultEpoch, since otherwise it may be possible
    // to declare faults adaptively to avoid challenged sectors.
    EffectiveFaultBeginEpoch()  block.ChainEpoch
    EffectiveFaultEndEpoch()    block.ChainEpoch
}

type SectorsAMT {sector.SectorNumber: SectorOnChainInfo}

// Balance of a StorageMinerActor should equal exactly the sum of PreCommit deposits
// that are not yet returned or burned.
type StorageMinerActorState struct {
    Sectors    SectorsAMT
    PoStState  MinerPoStState
    Info       MinerInfo

    _getStorageWeightDescForSector(sectorNumber sector.SectorNumber) actor_util.SectorStorageWeightDesc
    _getStorageWeightDescsForSectors(sectorNumbers [sector.SectorNumber]) actor_util.SectorStorageWeightDesc

    _getSectorOnChainInfo(sectorNumber sector.SectorNumber) (info SectorOnChainInfo, ok bool)
    _getSectorPower(sectorNumber sector.SectorNumber) (power block.StoragePower, ok bool)
    _getSectorDealIDsAssert(sectorNumber sector.SectorNumber) deal.DealIDs
}

type StorageMinerActorCode struct {
    GetWorkerKey(rt Runtime) filcrypto.VRFPublicKey
    OnCronTickEnd(rt Runtime)
    NotifyOfSurprisePoStChallenge(rt Runtime)
    ProcessSurprisePoSt(rt Runtime)

    PreCommitSector(rt Runtime, info sector.SectorPreCommitInfo)  // TODO: check with Magik on sizes
    ProveCommitSector(rt Runtime, info sector.SectorProveCommitInfo)
    ProcessVerifiedElectionPoSt(rt Runtime)
    DeclareFaults(rt Runtime, failingSet sector.CompactSectorSet)
    RecoverFaults(rt Runtime, recoveringSet sector.CompactSectorSet)

    _checkSurprisePoStSubmissionHappened(rt Runtime)
    _rtVerifySurprisePoSt(rt Runtime, onChainInfo sector.OnChainPoStVerifyInfo) bool
    _rtVerifySurprisePoStMeetsTargetReq(rt Runtime) bool
    _rtVerifySeal(rt Runtime, onChainInfo sector.OnChainSealVerifyInfo) bool
    _rtAbortIfSectorDidNotExist(rt Runtime, sectorNo sector.SectorNumber)

    _onMissedSurprisePoSt(rt Runtime)
    _onSuccessfulPoSt(rt Runtime)

    _slashCollateralForStorageFaults(
        rt          Runtime
        declared    sector.CompactSectorSet  // diff value
        detected    sector.CompactSectorSet  // diff value
        terminated  sector.CompactSectorSet  // diff value
    )
    _slashDealsForStorageFault(
        rt             Runtime
        sectorNumbers  [sector.SectorNumber]
        faultType      sector.StorageFaultType
    )

    _submitPowerReport(rt Runtime, lastPoSt block.ChainEpoch)
    _expirePreCommittedSectors(rt Runtime)
}

type MinerInfo struct {
    // Account that owns this miner.
    // - Income and returned collateral are paid to this address.
    // - This address is also allowed to change the worker address for the miner.
    Owner                   address.Address

    // Worker account for this miner.
    // This will be the key that is used to sign blocks created by this miner, and
    // sign messages sent on behalf of this miner to commit sectors, submit PoSts, and
    // other day to day miner activities.
    Worker                  address.Address
    WorkerVRFKey            filcrypto.VRFPublicKey

    // Libp2p identity that should be used when connecting to this miner.
    PeerId                  libp2p.PeerID

    // Amount of space in each sector committed to the network by this miner.
    SectorSize              sector.SectorSize
    WindowCount             UVarint
    SealPartitions          UVarint
    ElectionPoStPartitions  UVarint
    SurprisePoStPartitions  UVarint
}
