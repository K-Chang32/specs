import libp2p "github.com/filecoin-project/specs/libraries/libp2p"
import util "github.com/filecoin-project/specs/util"
import sealing "github.com/filecoin-project/specs/systems/filecoin_mining/sector"
import sector "github.com/filecoin-project/specs/systems/filecoin_mining/sector"
import address "github.com/filecoin-project/specs/systems/filecoin_vm/actor/address"
import block "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block"
import poster "github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster"
import power "github.com/filecoin-project/specs/systems/filecoin_blockchain/storage_power_consensus"

type Seed struct {}
type SectorCommitment struct {}

type SectorExpirationQueueItem struct {
    SectorNumber  sector.SectorNumber
    Expiration    block.ChainEpoch
}

type SectorExpirationQueue struct {
    Add(i SectorExpirationQueueItem)
    Pop() SectorExpirationQueueItem
    Peek() SectorExpirationQueueItem
    Remove(n sector.SectorNumber)
}

type SectorTable struct {
    SectorSize         sector.SectorSize
    ActiveSectors      util.UVarint
    CommittedSectors   util.UVarint
    RecoveringSectors  util.UVarint
    FailingSectors     util.UVarint
    TerminatedSectors  util.UVarint  // transient State that get reset on every constructPowerReport

    ActivePower()      block.StoragePower
    InactivePower()    block.StoragePower
}

type SectorOnChainInfo struct {
    SealCommitment  sector.SealCommitment
    State           SectorState
}

type SectorsAMT {sector.SectorNumber: SectorOnChainInfo}

type StorageMinerActor struct {
    // CollateralVault CollateralVault

    Sectors                SectorsAMT

    ProvingSet             sector.CompactSectorSet
    LastChallengePoSt      block.ChainEpoch

    SectorTable
    SectorExpirationQueue

    // contains mostly static info about this miner
    Info                   &MinerInfo

    // TODO: add the DePledgeCollateral
    // TODO: add the Sectors
    // TODO sectors []SectorInfo CID to AMT
    // TODO provingSet []SectorInfo CID to AMT

    // TODO: should we keep the same structure as before or putting all of that into a struct?
    // TODO do we need a `slashedAt`?
    // TODO owedStorageCollateral
    // TODO ProvingPeriodEnd   Epoch

    CommitSector(onChainInfo sealing.OnChainSealVerifyInfo)  // TODO: check with Magik on sizes

    SubmitPoSt(postSubmission poster.PoStSubmission)

    CheckPoStSubmissionHappened()
    // TODO: should depledge be in here or in storage market actor?

    // TODO: add GetOwner()
    // TODO: add GetPeerID()
    // TODO: add GetSectorSize()
    // TODO: add UpdatePeerID()
    // TODO: add UpdatePeerID()
    // TODO: add ChangeWorker()

    // TODO: do IsSlashed, IsLate belong here?

    DeclareFaults(failingSet sector.CompactSectorSet)
    RecoverFaults(recoveringSet sector.CompactSectorSet)

    constructPowerReport() power.PowerReport

    computeProvingPeriodEndSectorState()  // TODO

    verifyPoStSubmission(postSubmission poster.PoStSubmission) bool

    clearSector(sectorNo sector.SectorNumber)
    activateSector(sectorNo sector.SectorNumber)
    failSector(sectorNo sector.SectorNumber, incrementFaultCount bool)

    expireSectors()
}

type MinerInfo struct {
    // Account that owns this miner.
    // - Income and returned collateral are paid to this address.
    // - This address is also allowed to change the worker address for the miner.
    Owner       address.Address

    // Worker account for this miner.
    // This will be the key that is used to sign blocks created by this miner, and
    // sign messages sent on behalf of this miner to commit sectors, submit PoSts, and
    // other day to day miner activities.
    Worker      address.Address

    // Libp2p identity that should be used when connecting to this miner.
    PeerId      libp2p.PeerID

    // Amount of space in each sector committed to the network by this miner.
    SectorSize  util.BytesAmount
}
