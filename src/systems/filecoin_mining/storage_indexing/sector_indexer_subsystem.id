type PieceInclusionProof struct {}

type SectorIndexerSubsystem struct {

    SectorStore    SectorStore,
    SectorBuilders { SectorConfig : SectorBuilder },
    ProverID       UInt

	// call by StorageMiningSubsystem during AddingDealToSector
	// trigger getPieceInclusionProof
	// TODO: procedural call
	AddPieceToSector(deal StorageDeal, pieceRef CID) struct {
		sectorID SectorID,
		pip PieceInclusionProof,
	}

	// call by SectorIndexer itself to get pip of a deal
	getPieceInclusionProof(deal StorageDeal) PieceInclusionProof

	selectSectorBuilderByDeal(deal StorageDeal) SectorBuilder

}

// ----- old
// type Piece []byte

// type SectorIndexerSubsystem struct {
   //     AddPiece(
   //       piece Piece,
		 // sectorConfig SectorConfig,
   //     ) error | bool {
   //         sectorbuilder := SectorBuilders[sectorConfig];
   //     	   piecePath := SectorStore.WritePiece(piece);
	  //  response := sectorBuilder.addPiece(PiecePath);

	  //  MaybeSeal(response.StagedSector, response.BytesRemaining);
   //     }

   //     MaybeSeal(StagedSector StagedSector, BytesRmaining Uint);

   //     Seal(stagedSector StagedSector) {
   //     	    sealedPath := SectorStore.AllocateSealedSector(stagedSector.SectorSize);
			// response := SectorSealer.seal(stagedSector, sealedPath, ProverId);
			// SectorStore.RegisterMetadata(
			//   SectorMetadata {
			//     response.CommR,
			// 	response.PersistentAux,
			// 	response.PartialMerkleTreePath,
			//   });

   //     RetrievePiece(CommD Commitment, Start UInt, Length UInt) Piece {
   //     }
// }

// Indexed by CommR
type SectorMetadata struct {
	// CommR                   Commitment,
	// PersistentAux           SectorPersistentAux,
	// MerkleTreePath          Path,
}
