type PieceInclusionProof struct {}
type AddDealToSectorResponse struct {
	sectorID SectorID,
	pip PieceInclusionProof,
}

type SectorIndexerSubsystem struct {

    SectorStore    SectorStore,
    SectorBuilders { SectorConfig : SectorBuilder },
    ProverID       UInt

	// call by StorageMiningSubsystem when adding a deal to sector
	// trigger getPieceInclusionProof
	AddDealToSector(deal StorageDeal) AddDealToSectorResponse

	indexSectorByDealExpiration(sectorID SectorID, deal StorageDeal) struct {}

	// call by SectorIndexer itself to get pip of a deal
	getPieceInclusionProof(deal StorageDeal) PieceInclusionProof

	OnNewTipset(chain Chain, epoch Epoch) struct {}

	lookupSectorByExpiry(currentEpoch Epoch) [SectorID]

	purgeSectorWithNoLiveDeals(sectorIDs [SectorID]) struct{}	

	selectSectorBuilderByDeal(deal StorageDeal) SectorBuilder

}

// ----- old
// type Piece []byte

// type SectorIndexerSubsystem struct {
   //     AddPiece(
   //       piece Piece,
		 // sectorConfig SectorConfig,
   //     ) error | bool {
   //         sectorbuilder := SectorBuilders[sectorConfig];
   //     	   piecePath := SectorStore.WritePiece(piece);
	  //  response := sectorBuilder.addPiece(PiecePath);

	  //  MaybeSeal(response.StagedSector, response.BytesRemaining);
   //     }

   //     MaybeSeal(StagedSector StagedSector, BytesRmaining Uint);

   //     Seal(stagedSector StagedSector) {
   //     	    sealedPath := SectorStore.AllocateSealedSector(stagedSector.SectorSize);
			// response := SectorSealer.seal(stagedSector, sealedPath, ProverId);
			// SectorStore.RegisterMetadata(
			//   SectorMetadata {
			//     response.CommR,
			// 	response.PersistentAux,
			// 	response.PartialMerkleTreePath,
			//   });

   //     RetrievePiece(CommD Commitment, Start UInt, Length UInt) Piece {
   //     }
// }

// Indexed by CommR
type SectorMetadata struct {
	// CommR                   Commitment,
	// PersistentAux           SectorPersistentAux,
	// MerkleTreePath          Path,
}
