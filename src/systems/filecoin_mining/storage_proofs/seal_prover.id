type SealPublicInputs struct {}
type MerkleTree struct {}
type PieceInclusionProof struct {}
type Error String

type SealResponse struct {
     CommD                 Commitment
     CommR                 Commitment
     Proof                 SealProof
     PersistentAux         SectorPersistentAux
     MerkleTreePath        Path // TODO: This may be a partially-cached tree.
}

type SealProofConfig struct {
    partitionCount UInt
    subsectorsCount UInt
}

type SNARKProof struct { //<curve, system> {
     config SealProofConfig
     proofBytes Bytes
}

type FilecoinSNARKProof struct {} //<bls12-381, Groth16>

type SealProof struct {
     snarkProof      SNARKProof,
     susbsectorCount UVarint,
}

type SealProver struct {
  GenerateCommP() Commitment
  GenerateCommD() Commitment

  SealSector(
		SectorConfig   SectorConfig,
		unsealedPath   Path,
		sealedPath     Path,
		proverID       ProverID,
		ticket         Ticket, // Assuming this is defined  elsewhere.
		sectorID       union { SectorID, Error, SealResponse }
  ) struct {}

  GeneratePieceInclusionProof(
    Tree          MerkleTree, //MerkleTree<Rephash>,
    PieceStart    Uint,
    PieceLength   Uint,
  ) union { Error, PieceInclusionProofs }

  VerifyPieceInclusionProof() struct {}

  MaxUnsealedBytesPerSector(SectorSize UInt) UInt
}