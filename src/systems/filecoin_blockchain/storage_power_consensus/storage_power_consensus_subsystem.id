import addr "github.com/filecoin-project/specs/systems/filecoin_vm/actor/address"
import filcrypto "github.com/filecoin-project/specs/libraries/filcrypto"
import block "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block"
import chain "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/chain"
import st "github.com/filecoin-project/specs/systems/filecoin_vm/state_tree"
import base_mining "github.com/filecoin-project/specs/systems/filecoin_mining"

type StoragePowerConsensusSubsystem struct {//(@mutable)
    // TODO: this is incorrect, it does not belong
    powerTable           PowerTable
    actor                StoragePowerActor
    associatedStateTree  &st.StateTree  // TODO: remove this. should not store this here.

    GenerateElectionProof(tipset block.Tipset) block.ElectionProof
    ChooseTipsetToMine(tipsets [block.Tipset]) [block.Tipset]

    ec                   ExpectedConsensus

    // call by BlockchainSubsystem during block reception
    ValidateBlock(block block.Block) error

    validateElectionProof(base.ElectionProof, base.Address)

    validateTicket(base.Ticket, base.Address)

    computeTipsetWeight(tipset block.Tipset) block.ChainWeight

    IsWinningElectionProof(electionProof base.ElectionProof, workerAddr base.Address) bool

    StoragePowerConsensusError() base.StoragePowerConsensusError

    // Randomness methods

    // call by StorageMiningSubsystem during block production
    GetTicketProductionSeed(chain blockchain.Chain, epoch Epoch) base.Ticket

    // call by StorageMiningSubsystem during block production
    GetElectionProofSeed(chain blockchain.Chain, epoch Epoch) base.Ticket

    // call by StorageMiningSubsystem in sealing sector
    GetSealSeed(chain chain.Chain, epoch Epoch) base_mining.SealSeed

    // call by StorageMiningSubsystem after sealing
    GetPoStChallenge(chain chain.Chain, epoch Epoch) base_mining.PoStChallenge

    GetFinality()   Epoch
}

type ExpectedConsensus struct {
    // ComputeWeight(Chain)							        ChainWeight
    // IsConsensusFault([Block])						    bool
}

type PowerTable struct {
    // all power here is always verified
    RegisterMiner(addr base.Address)
    miners {base.Address: StorageMiner}
    GetMinerPower(addr base.Address) base.StoragePower
    GetTotalPower() base.StoragePower
    GetMinerPublicKey(addr base.Address) filcrypto.PublicKey
    RemovePower(addr base.Address)
}

type StorageMiner struct {
    minerAddress       base.Address
    minerStoragePower  base.StoragePower
    minerPK            filcrypto.PublicKey
}
