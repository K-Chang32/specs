import addr "github.com/filecoin-project/specs/systems/filecoin_vm/actor/address"
import libp2p "github.com/filecoin-project/specs/libraries/libp2p"
import block "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block"
import actor "github.com/filecoin-project/specs/systems/filecoin_vm/actor"
import util "github.com/filecoin-project/specs/util"

type PowerTableEntry struct {
    ActivePower             block.StoragePower
    InactivePower           block.StoragePower
    AvailableBalance        actor.TokenAmount
    LockedPledgeCollateral  actor.TokenAmount
}

type PowerReport struct {
    ActivePower            block.StoragePower
    InactivePower          block.StoragePower
    SlashDeclaredFaults    util.UVarint
    SlashDeletedFaults     util.UVarint
    SlashTerminatedFaults  util.UVarint
}

// type PowerTableHAMT {actor.ActorID: PowerTableEntry}
type PowerTableHAMT {addr.Address: PowerTableEntry}  // TODO: covert ActorID to address

// TODO: Diagram for state transition to someones power
// TODO: increment and decrement?
// TODO: What does graceful removal look like?

type StoragePowerActor struct {
    PowerTable  PowerTableHAMT
    EC          ExpectedConsensus

    // call by StorageMiningSubsytem on miner creation
    CreateStorageMiner(
        // TODO: document differences in Addr, Key and ID accross spec
        ownerAddr   addr.Address
        workerAddr  addr.Address
        peerId      libp2p.PeerID  // TODO: will be removed likely (see: https://github.com/filecoin-project/specs/pull/555#pullrequestreview-300991681)
    ) addr.Address

    RemoveStorageMiner(addr addr.Address)
    verifyStorageMiner(addr addr.Address) bool

    // PowerTable Operations
    GetTotalPower() block.StoragePower

    // sectorSize should be passed in from SM.Info()
    // newPower = numSectors util.UVarint * sectorSize sector.SectorSize
    IncrementPower(newPower block.StoragePower)
    DecrementPower(newPower block.StoragePower)
    // SectiveActivePower(newPower block.StoragePower)

    GetPledgeCollateralReq(newPower block.StoragePower) actor.TokenAmount
    IsPledgeCollateralSatisfied() bool
    AddBalance()
    WithdrawBalance(amount actor.TokenAmount)
    slashPledgeCollateral(address addr.Address, amount actor.TokenAmount)

    lockPledgeCollateral(address addr.Address, amount actor.TokenAmount)
    unlockPledgeCollateral(address addr.Address, amount actor.TokenAmount)

    ProcessPowerReport(report PowerReport)

    ReportConsensusFault(
        // slasherAddr  addr.Address TODO: fromActor
        faultType  ConsensusFaultType
        proof      [block.Block]
    )

    Surprise(ticket block.Ticket) [addr.Address]
    // this should be part of ReportConsensusFault, numSectors should be all sectors
    // ReportUncommittedPowerFault(cheaterAddr addr.Address, numSectors UVarint)
}
