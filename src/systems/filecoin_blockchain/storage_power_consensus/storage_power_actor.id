import filcrypto "github.com/filecoin-project/specs/libraries/filcrypto"
import addr "github.com/filecoin-project/specs/systems/filecoin_vm/actor/address"
import libp2p "github.com/filecoin-project/specs/libraries/libp2p"
import block "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block"
import actor "github.com/filecoin-project/specs/systems/filecoin_vm/actor"
import util "github.com/filecoin-project/specs/util"

type PledgeCollateralBalance struct {
    Pledged   actor.TokenAmount
    Frozen    actor.TokenAmount
    Available actor.TokenAmount
}

type StoragePowerActor struct {
    // TODO: bytesamount might be inefficient
    Miners             {addr.Address: block.StoragePower}

    // TODO: decide on locking pc locked in SPA or StorageMiner?
    PledgeCollaterals  {addr.Address: actor.PledgeCollateralBalance}
    PowerTable
    // TODO: verify its relationship with SPA
    ExpectedConsensus

    // call by StorageMiningSubsytem on miner creation
    CreateStorageMiner(
        // TODO: document differences in Addr, Key and ID accross spec
        ownerAddr     addr.Address
        workerPubKey  filcrypto.PubKey
        sectorSize    util.UInt
        peerId        libp2p.PeerID  // TODO: will be removed likely (see: https://github.com/filecoin-project/specs/pull/555#pullrequestreview-300991681)
    ) addr.Address

    // PowerTable Operation - consider remove
    IncrementPower(address addr.Address, numSectors util.UVarint)
    DecrementPower(address addr.Address, numSectors util.UVarint)
    GetTotalPower() block.StoragePower

    GetPledgeCollateralReq(newStorage block.StoragePower)
    CommitPledgeCollateral()
    DecommitPledgeCollateral(amount actor.TokenAmount)

    ReportConsensusFault(
        // slasherAddr  addr.Address TODO: fromActor
        faultType  ConsensusFaultType
        proof      [block.Block]
    )

    Surprise(ticket block.Ticket) [addr.Address]
    // this should be part of ReportConsensusFault, numSectors should be all sectors
    // ReportUncommittedPowerFault(cheaterAddr addr.Address, numSectors UVarint)
}

// // What does graceful removal look like?

// TODO: old methods, should be removed
// UpdateStoragePowerSubsystem(Tipset, StateTree)
// VerifyElectionProof(addr.Address, ElectionProof) bool
// NotifyStorageFault(addr.Address)
