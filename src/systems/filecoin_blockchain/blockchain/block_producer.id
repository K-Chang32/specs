import base_blockchain "github.com/filecoin-project/specs/systems/filecoin_blockchain"

type BlockProducer struct {
	// call by StorageMiningSubsystem when elected as a leader
	// a procedural call that calls GetMostProfitableMessages(minerAddr Address)
	// and then get back the messages and call AssembleBlock
	// TODO minerAddr is of type StorageMiner.Address
	GenerateBlock(electionProof base_blockchain.ElectionProof, T0 base_blockchain.Ticket, tipset Tipset, minerAddr base_blockchain.Address) struct{}

	// call by BlockProducer itself after getting back messages
	AssembleBlock(electionProof base_blockchain.ElectionProof, T0 base_blockchain.Ticket, tipset Tipset, minerAddr base_blockchain.Address, messages [base_blockchain.Message]) Block
}

type BlockStore struct {
    GetBlock(cid CID) Block
    PutBlock(block Block) error
}

/*
func (miner *BlockProducer_I) MineBlock(messages []Message) Block {
	var chain = miner.Blockchain()
    T := chain.CurrentMiningEpoch()
    K := Param_ElectionLookback

    if T - K < 0 {
        panic("");  // TODO: handle genesis block
    }

	var parentTipset    = chain.TipsetAtEpoch(T)
	var lookbackTipset  = chain.TipsetAtEpoch(T - K)

	var currSeed = lookbackTipset.ElectionSeed()
    var currTicket Ticket
    var tickets []Ticket

    for {
        currTicket = Ticket.Generate(nil, miner.VRFKeyPair(), currSeed)
        tickets = append(tickets, currTicket)

        if currTicket.IsWinning(miner.PowerFraction()) {
			ret := &BlockI {
				minerAddress: miner.Address(),
				tickets:      tickets,
				parentTipset: parentTipset,
				weight:       ComputeBlockWeight(parentTipset, tickets),
				height:       T + 1,
				stateTree:    parentTipset.StateTree(),
				messages:     messages,
				timestamp:    CurrentTime(),
				blockSig:     nil,
			};
			ret.blockSig = miner.SigKeyPair().Sign(ret.ComputeUnsignedFingerprint())
			return ret
        }
    }
}
*/